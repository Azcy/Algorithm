# 	        聪明的kk(动态规划法)

	时间限制：1000 ms  |  内存限制：65535 KB
	难度：3
	描述
	聪明的“KK”
	非洲某国展馆的设计灵感源于富有传奇色彩的沙漠中陡然起伏的沙丘，体现出本国不断变换和绚丽多彩的自然风光与城市风貌。展馆由五部分组成，馆内影院播放名为《一眨眼的瞬间》的宽银幕短片，反映了建国以来人民生活水平和城市居住环境的惊人巨变。
	可移动“沙丘”变戏法 的灵感源于其独特而雄伟的自然景观——富于传奇色彩的险峻沙丘。宏伟的结构、可循环的建材，与大自然相得益彰。环绕一周，发现它正是从沙丘那不断变换的形态中汲取灵感的。外形逼真到无论从哪个角度去观察，都能清楚地辨识出沙丘的特征。
	它“坡面”高达20米，微风吹来，你是否感觉到沙的流动？用手去触碰，却发现原来是“魔术戏法”。它表面的不锈钢面板呈现出一种富于变幻的色彩，从不同角度观察，呈现不同色泽，由此来模仿流动沙丘的光感。
	走进第三展厅有一个超大的屏幕，通过奇妙的特效，让观众犹如亲身来到浩瀚的沙漠。更为奇妙的是，只见一个小动物“KK”正从沙漠区域（矩形）的左上角沿着向右或向下的方向往右下角跑去。KK太聪明了，它居然能在跑的过程中会选择吃掉尽可能多的虫子线路。
	你知道它吃掉多少虫子吗？
	输入
	第一行：N M (1≤N M≤20 0≤Xij≤500(i=1,2„.N, j=1,2„,M)
	)表示沙漠是一个N*M的矩形区域
	接下来有N行：每行有M个正整数，Xi1 Xi2 ……Xim 表示各位置中的虫子数（单个空格隔开）
	假设“KK”只能向右走或向下走。
	输出
	输出有一个整数， 表示“KK”吃掉最多的虫子数。
	样例输入
	3 4
	3 1 2 8
	5 3 4 6
	1 0 2 3
	样例输出
	24

## 思路
简单的dp问题，开始看到这道题一直想用搜索来做，分为两个方向搜索，后来自己写的时候发现写不下去了，因为这里的每次的两个方向的起始值是一样的，所以应该是思路有问题，所以就换了种思路，用动态规划来做，动态规划额的思想是从后面开始递推，保证当前位置的最优，所以我们就直接模拟kk走过的路线，kk只能向右走，或者向下走，我们就每次对这两个方向进行比较，选出一个最大值，当前的步数取决于前一步所走的位置；

所以我们就能得到状态关系式，maxAdd[i][j]=Math.max(maxAdd[i-1][j],maxAdd[i][j-1])+a[i][j];因为是从后面开始递归，最大值的前一步就是向上，或者向左；

**数组表如下：**

![](https://github.com/Azcy/Algorithm/blob/master/%E5%8D%97%E9%98%B3OJ/image/%E8%81%AA%E6%98%8E%E7%9A%84kk.png)

## 代码实现

	/**
	@param n 行数
	@param m 列数
	@param a[][] 用户来存放输入的数组，a[0][0~m]为0，a[0~n][n]为0
	@param maxAdd[][] 决策数组，用来存储动态规划每一步的决策结果
	*/
	public static void main(String[] args)
	{
		Scanner in=new Scanner(System.in);
		//行数 
		int n=in.nextInt();
		//列数
		int m=in.nextInt();
		//创建一个数组，存放输入的值
		int a[][]=new int[n+1][m+1];
		//定义一个决策数组，用来存储动态规划每一步的决策结果
		int maxAdd[][]=new int [n+1][m+1];
		//输入
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				a[i][j]=in.nextInt();
				maxAdd[i][j]=a[i][j];
			}
		}
		//继续决策
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				maxAdd[i][j]=Math.max(maxAdd[i-1][j],maxAdd[i][j-1])+a[i][j];
			}
		}
		//输出最大数值和，即最终的决策结果
		System.out.println(maxAdd[n][m]);
		
	}

##  [具体代码点击此处](https://github.com/Azcy/Algorithm/blob/master/%E5%8D%97%E9%98%B3OJ/java/CleverKk.java)