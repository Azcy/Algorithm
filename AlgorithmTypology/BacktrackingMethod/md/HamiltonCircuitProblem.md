# 哈密顿回路问题
## 1.问题
爱尔兰数学家哈密顿提出了著名的周游世界问题。设正十二面体的20个顶点代表20个城市，哈密顿回路问题要求从一个城市出发，经过每个城市恰好一次，然后回到出发城市。

## 2.思路
回溯法求解哈密顿回路问题，首先把所有顶点的访问标志初始化为0，然后在解空间树中从根结点开始搜索，如果从根结点到当前结点对应一个部分解，即满足约束条件，则在当前结点处选择第一棵子树继续搜索，否则，对当前子树的兄弟结点进行搜索，如果当前结点的所有子树都已尝试过并且发生冲突，则回溯到当前结点的父结点。例如对于(a)所示的无向图，求解哈密顿回路在解空间树中的搜索过程如图(b)所示，具体过程如下：
![](https://github.com/Azcy/Algorithm/blob/master/AlgorithmTypology/BacktrackingMethod/image/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF%E9%97%AE%E9%A2%98.png)

**搜索过程：**

(1)在解空间树中从根结点1开始搜索，首先将x1设置为1，到达结点2，表示哈密顿回路从顶点1开始;

(2)然后将x2设置为1，到达结点3，但顶点1重复访问，搜索结点2的兄弟子树，将x2置为2，构成哈密顿回路的部分解(1,2);

(3)在经过结点5和结点6的失败和尝试后，将x3置为3，将哈密顿回路的部分解扩展到(1,2,3);

(4)在经过结点8、结点9和结点10的失败尝试后，将x4置为4，强哈密顿回路的部分解扩展到(1,2,3,4);

(5)在经过结点12、结点13、结点14和结点15的失败和尝试后，将x5置为5，将哈密顿回路的部分解扩展到(1,2,3,4,5),但是在图(a)中从顶点1没有边，引起回溯，将x4置为5，到达结点17，构成哈密顿回路的部分(1,2,3,5);

(6)在经过结点18、结点19和结点20的失败的尝试后，将x5置为4，将哈密顿回路的部分解扩展到(1,2,3,5,4)而在图(a)中从顶点4到顶点1存在边，所以，找到了一条哈密顿回路(1,2,3,5,4)，搜索过程结束。


## 3.伪代码
设数组x[n]存储哈密顿回路上的顶点，数组visited[n]存储顶点的访问标志,visited[i]=1表示哈密顿回路经过顶点i，算法用伪代码描述如下。

	输入：无向图 G=(V,E)
	输出：哈密顿回路
	1.将顶点数组x[n]初始化为0，标志数组visited[n]初始化为0；
	2.从顶点0出发构造哈密顿回路：visited[0]=1;x[0]=1;k=1;
	3.while(k>=1)
		3.1 x[k]=x[k]+1;
		3.2 若n个顶点没有被穷举完，则执行下列操作
			3.2.1 若顶点x[k]不在哈密顿回路上并且(x[k-1],x[k])∈E，转步骤3.3;
			3.2.2 否则，x[k]=x[k]+1,搜索下一个顶点；
		3.3 若数组x[n]已形成哈密顿路径,则输出数组x[n],算法结束;
		3.4 若数组x[n]构成哈密顿路径的部分解，则k=k+1,转步骤3；
		3.5 否则，取消顶点x[k]的访问标志，重置x[k],k=k-1,转步骤3.

## 4.算法分析
在哈密顿回路的可能解中，考虑到约束条件xi！=xj(1=<i,k<=n,i!=j),则可能解应该是(1,2,3...,n)的一个排列，对应的解空间树中至少有n！个叶子结点，而回溯法只搜索了其中的21个结点后就找到了问题的解。

## 5.算法实现
	public class HamiltonCircuitProblem
	{
		/**
		哈密顿回路问题
		@param arc[][] 存放顶点间的关系
		@param visited[] 标志数组，用来标记该顶点是否有被访问过，访问过为1，未访问过为0
		@param x[] 顶点数组，存放顶点的编号。
		@param k 该变量用来表示当前的位置，当k=n-1时，求解结束
		@param n 表示顶点的个数
		*/
		private void Hamilton(int n,int arc[][])
		{
				int x[]=new int[n]; 
				int k,i;
				int visited[]=new int[n]; //创建个数为n的标志数组
				//初始化顶点数组和标志数组
				for (i=0; i<n; i++) {
				 	x[i]=0;
				 	visited[i]=0;
				}
				visited[0]=1; //从顶点出发
				k=1;
				x[0]=0;
				while(k>=1)
				{
					x[k]+=1;  //搜索下一个结点
					while(x[k]<n)
					{
					if(visited[x[k]]==0&&arc[x[k-1]][x[k]]==1)//如果当前结点没有被访问过，且与前一个结点相连，则满足条件
						{
							break;
						}else
						{
							x[k]+=1;
						}
					}
					if(x[k]<n&&k==n-1&&arc[x[k]][0]==1)
					{
						for( int m=0;m<n;m++)
						{
							System.out.print(x[m]+1+" ");  //输出顶点的编号，编号从1开始
						}
						return ;
						
					}
					
					if(x[k]<n&&k<n-1)  
					{
						visited[x[k]]=1;
						k+=1;     //继续访问下一个结点
					}
					else    //回溯
					{
						x[k]=0; //把当前结点置为0
						k-=1; //回到前一个节点
						visited[x[k]]=0; //把前一个结点的访问设置为0
					}
				}
		}
		
		public static void main(String[] args)
		{
			//arc为存储顶点间的关系
			int arc[][]=new int[][]{{0,1,0,1,0},{1,0,1,0,1},{0,1,0,1,1},{1,0,1,0,1},{0,1,1,1,0}};
			new HamiltonCircuitProblem().Hamilton(5,arc);
		}
	
	}

----------
3/30/2017 1:26:19 PM 