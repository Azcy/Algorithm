# 八皇后问题
## 1.问题
在8x8的棋盘上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同意斜线上。可以把八皇后问题扩展到n皇后问题，即在nxn的棋盘上摆放n个皇后，使任意两个皇后都不能处于同一行、同一列或一斜线上。

## 2.想法
显示，棋盘的每一行可以并且必须摆放一个皇后，所以，n皇后问题的可能解用一个n元向量(x1,x2,...,xn)表示，即第i个皇后摆放在第i行第xi列的位置(1=<i=<n且1=<xi=<n)。由于两个皇后不能位于同一列，所以，n皇后问题的解向量必须满足约束条件xi!=xj。

可以将n皇后问题的n x n棋盘堪称矩阵，设皇后i和皇后j的摆放位置分别是(i,xi)和(j,xj)，则在棋盘上斜率为-1的同一条斜线上，满足条件i-xi=j-xj，如图(a)所示；在棋盘斜率为1的同一条斜线上，满足条件i+xi=j+xj，如图(b)所示。综合上述两种情况，n皇后问题的解满足的约束条件:|i-j|!=|xi-xj|。

**步骤：**

1. 首先把皇后1摆放到它所在行的第一个位置，也就是第一行第一列，得到图8.7(a);
2. 对于皇后2，在经过第一列和第二列的尝试后，摆放到第二行第三列，得到图8.7(b);
3. 对于皇后3，摆放到第三行的那一列都会引起冲突，进行回溯，回溯到对皇后2的处理，把皇后2摆放到下一位置，也就是第二行第四列，得到图8.7(d);
4. 对于皇后3，在经过第一轮的尝试后，摆放到第三行第二列，得到图8.7(e);
5. 对于皇后4，摆放到第四行的哪一列上都会引起冲突，进行回溯，回到对皇后3的处理，皇后3摆放到第三行的哪一列上都会引起冲突，再次进行回溯，但此时皇后2位于棋盘的最后一列，继续回溯，回到对皇后1的处理，把皇后1摆放到第一行第二列，得到图8.7(g);
6. 接下来，把皇后2摆放第二行第四列的位置，把皇后3摆放到第三行第一列的位置，把皇后4摆放到第四行第三列得位置，得到四皇后问题的一个解，如图8.7(j)。
![](https://github.com/Azcy/Algorithm/blob/master/AlgorithmTypology/BacktrackingMethod/image/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.jpg)

## 3.伪代码

	回溯法求解n皇后问题Queen
	输入：皇后的个数n
	输出：n皇后问题的解x[n]
	1.初始化解向量x[n]={-1};
	2.k=0;
	3.while(k>=0)
		3.1 把皇后k摆放在下一列的位置，即x[k]++；
		3.2 从x[k]开始依次考察每一列，如果皇后k摆放在x[k]位置不发送冲突，则转步骤3.3；
		    否则x[k]++试探下一列；
		3.3 若n个皇后已全部摆放，则输出一个解，算法结束；
		3.4 若尚有皇后没摆放，则k++，转步骤3摆放下一个皇后；
		3.5 若x[k]出界，则回溯，x[k]=-1,k--,转步骤3重新摆放皇后k；
	4.退出循环，说明n皇后问题无解。

## 算法分析
在n皇后问题的可能解中，考虑到约束条件xi！=xj(1=<i,j<=n,i!=j),则可能解应该是(1,2,...,n)的一个排列，对应的解空间树种有n！个叶子结点，每个叶子结点代表一种可能解。在n=4的情况下，解空间树共有341个结点，但在实际搜索过程中，遍历操作只涉及27个结点就找到了满足条件的解。


## 代码实现

	/**
	八皇后问题
	@param x[i] 表示第i个皇后摆放摆放在第i行第x[i]列的位置
	@param k 表示第k个皇后
	*/
	public void Queen(int n)
	{
		int x[]=new int[n];
		//初始化
		for (int i=0; i<n; i++) {
		 	x[i]=-1;
		}
		int k=0;
		while(k>=0)      //摆放皇后k，注意0=<k<n
		{
			x[k]++;       //在下一列摆放皇后k
			while(x[k]<n)
			{
				if(x[k]<n&&Place(k,x)==0) 
				{
					break;//符合则继续进行
				}else
				{
					x[k]++; //发生冲突，皇后k试探下一列
				}
			}
			if(x[k]<n&&k==n-1)  //得出一个可行解，输出
			{
				for(int i=0;i<n;i++)
				{
					System.out.print(x[i]+1+" ");
				}
				return;
			}
			
			if(x[k]<n&&k<n-1) //尚有皇后未摆放
			{
				k++;          //准备摆放下一个皇后
			}else
			{
				x[k]=-1;        //重置x[k]
				k--;             //回溯
			}
		}
		System.out.println("无解");
		
	}
	
	private static  int Place(int k,int x[])
	{
		for(int i=0;i<k;i++)
		{
			if(x[i]==x[k]||Math.abs(i-k)==Math.abs(x[i]-x[k])) //判断是否在同一列，且斜率1和-1是否在同一个斜线上
			{
				return 1;              //冲突返回1
			}
			                //不冲突返回0
		}return 0;
	}

###  [详细代码请点击此处](https://github.com/Azcy/Algorithm/blob/master/AlgorithmTypology/BacktrackingMethod/java/EightQueenPromble.java)

----------
3/30/2017 5:31:29 PM 