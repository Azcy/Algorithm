# 图着色问题

## 1.题目
给定无向连通图G=(V,E),求最小的整数m，用m种颜色对G中的顶点着色，使得任意两个相邻顶点着色不同。

## 2.思路
回溯法求解图着色问题，首先把所有顶点的颜色初始化为0，然后依次为每个顶点着色。在图着色问题的解空间树中，如果从根结点到当前结点对应一个部分解，也就是所有的颜色指派都没有冲突，则在当前结点处选择第一棵子树继续搜索，它就是为下一个顶点着颜色1，否则，对当前子树的兄弟子树继续搜索，也就是为当前顶点着下一个颜色，如果所有m种颜色都已尝试过并且都发送冲突，则回溯到当前结点的父结点处，上一个顶点的颜色被改变，依此类推。

**例子**

在下图(a)所示的无向图中求解三着色问题，在解空间树中的搜索过程如图(b)所示，具体过程如下：

(1)在解空间树中，从根节点除非，搜索第1棵子树，即为顶点A着颜色1；

(2)再搜索结点2的第一棵子树，即为顶点B着颜色1，这导致一个不可行解，回溯到结点2，选择结点2的第二棵子树，即为顶点B着颜色2；

(3)在为顶点C着颜色时，经过颜色1和颜色2的失败长时候，选择结点4的第3棵子树，即为顶点C着颜色3；

(4)在结点7选择第1棵子树，即为顶点D着颜色1，但是在为顶点E着色时，顶点E五路着三种颜色的哪一种均发生冲突，于是导致回溯，在结点7选择第2棵子树叶会发生冲突，于是，选择结点7的第3棵子树，即顶点D着颜色3；

(5)在结点10选择第1棵子树，即为顶点E着颜色1，得到了一个可行解(1,2,3,3,1)
![](https://github.com/Azcy/Algorithm/blob/master/AlgorithmTypology/BacktrackingMethod/image/%E5%9B%BE%E7%9D%80%E8%89%B2%E5%AE%9E%E4%BE%8B.png)

## 3.步骤
图G=（V，E），m种颜色

	1. 设置数组clor[n]，表示顶点的着色情况,将数组color[n]初始化
	2. k=0;
	3. while(k>=0)
		3.1 依次考察每一种颜色，若顶点k的着色与其他顶点的着色不发生冲突，则转步骤3.2；
		否则，搜索下一个颜色。
		3.2 若顶点已全部着色，则输出数组color[n],返回；
		3.3 若顶点k是一个合法着色，则k=k+1，转步骤3处理下一个顶点;
		3.4 否则，重置顶点k的着色情况，k=k-1，转步骤3回溯。

## 算法分析
用m种颜色为一个具有n个顶点的无向图着色，共有m^n种可能的着色组合，因此，解空间树是一棵完全m叉树，树中每一个结点都有m棵子树，最后一层有m^n个叶子结点，每个叶子结点代表一种可能着色，最坏情况下的时间性能是O(m^n)。对于上图(a)所示无向图，解空间树共有364个结点，而回溯法只搜索了其中14个点后找到了问题的解。

## 代码实现
假设n个顶点的无向图采用邻接矩阵存储，数组arc[n][n]存储顶点之间边的情况，color[n]存储n个顶点的着色情况。代码如下：

		/**
		图着色
		@param m 颜色数量
		@param n 无向图的顶点数
		@param color[] 用来存放每个顶点的颜色
		*/
		public void GraphColour(int m,int n)
		{
			int color[]=new int[n];
			int i,k;
			for(i=0;i<n;i++)  //将数组color[n]初始化为0
			{
				color[i]=0;
			}
			
			k=0;
			while(k>=0)
			{
				color[k]=color[k]+1;   //取下一种颜色
				while(color[k]<=m)
				{
					if(OK(k,color)==1)             //如果符合要求则赋值
						break;
					else
						color[k]=color[k]+1;   //取下一种颜色
				}
				
				if(color[k]<=m&&k==n-1) //如果图着色完成，输出
				{
					for(i=0;i<n;i++)
					{
						System.out.print(color[i]+" ");
					
					}	return;
				}
				
				if(color[k]<=m&&k<n-1)  
				{
					k++;  //处理下一个点；
				}else  //前面的颜色已经用完了，当前颜色不符合。
				{
					color[k]=0;  //令当前颜色为0，k回退上一个位置，从color[k]+1开始、
					k--;//回溯
				}
			}
			
		}
		//用来表示顶点之间的连接
		int arc[][]=new int[][]{{0,1,1,0,0},{1,0,1,0,1},{1,1,0,0,1},{0,1,0,0,1},{0,1,1,1,0}};
		//判断顶点k的着色是否发生冲突
		public int OK(int k,int color[])
		{
			for(int i=0;i<k;i++)
			{
				if(arc[k][i]==1&&color[i]==color[k])
				return 0;
			}
			return 1;
		}
			
	

## [ 详细代码请点击](https://github.com/Azcy/Algorithm/blob/master/AlgorithmTypology/BacktrackingMethod/java/GraphColouring.java)

----------

3/29/2017 2:55:06 PM 
			