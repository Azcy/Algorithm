# 批处理作业调度问题
## 1.问题
n个作业{1,2,..,n}要在两台机器上处理，每个作业必须先由机器1处理，然后再由机器2处理，机器1处理作业i所需时间为ai，机器2处理作业i所需时间为bi(1=<i<=n),**批处理作业调度问题**要求确定这n个作业的最优处理顺序，使得从第1个作业在机器1处理开始，到最后一个作业在机器2上处理结束所需时间少。

## 2.想法
批处理作业的一个最优调度应使机器1没有空闲时间，且机器2的空闲时间最小。可以证明，存在一个最优调度作业使得在机器1和机器2上作业以相同次序完成。

设数组x[n]表示n个作业批处理的一种调度方案，其中x[k]表示第k个作业的编号，sum1[n]和sum2[n]保存在调度过程中机器1和机器2的当前完成时间，其中sum1[k]表示在安排第k个作业后机器1的当前完成时间，sum2[k]表示安排第k个作业后机器2的当前完成时间，且根据下式

	sum1[k]=sum1[k-1]+作业k在机器1的处理时间
	sum2[k]=max{sum1[k],sum2[k-1]}+作业x[k]在机器2的处理时间

## 3.伪代码
设数组a[n]存储n个作业在机器1上的处理时间，b[n]存储n个作业在机器2上的处理时间，回溯法求解批处理调度问题用伪代码描述如下：
	
	输入：n个作业在机器1上的处理时间a[n],在机器2上的处理时间b[n]
	输出：最优调度系列x[n]
	1.初始化解向量x[n]={-1};最短完成时间bestTime=MAX;
	2.初始化调度方案机器1和机器2的完成时间：
		sum1[n]=sum2[n]={0};k=1;
	3.while(k>=1)
		3.1 依次考察每一个作业，如果作业x[k]尚未处理，则转步骤3.2，否则尝试下一个作业，即x[k]++；
		3.2 处理作业x[k]:
			3.2.1 sum1[k]=sum1[k-1]+a[x[k]];
			3.2.2 sum2[k]=max{sum1[k],sum2[k-1]}+b[x[k]];
			3.2.3 若sum2[k]<bestTime,则转步骤3.3，否则实施剪枝；
		3.3 若n个作业已全部处理，则输出一个解；
		3.4 若尚有作业没被处理，则k++，转步骤3处理下一个作业；
		3.5 回溯，x[k]=-1;k--,转步骤3重新处理第k个作业。

## 4.算法分析
对于批处理作业调度问题，由于要从n个作业的所有排列中找出具有最早完成时间的作业调度，所以，批处理作业调度问题的解空间是一棵排列树，并且要搜索整个解恐惧树才能确定最优解，因此，其时间性能是O(n!)。相对于蛮力法求解批处理调度问题，由于在搜索过程中利用了已得到的最短完成时间进行剪枝，所以，能够提供搜索速度。

## 5.算法实现
	/**
	批处理作业调度问题
	@param a[] 存储n个作业在机器1上的处理时间
	@param a[] 存储n个作业在机器2上的处理时间
	@param n 一共有n个作业
	@param sum1[]存储机器1的完成时间
	@param sum2[]存储机器2的完成时间
	@return 返回最短时间
	*/
	 public int BatchJob(int a[],int b[],int n)
	 {
	 	int i,k;
	 	//x[]为安排作业
	 	int x[]=new int [n+1];
	 	//机器1上的完成时间
	 	int sum1[]=new int [n+1];
	 	//机器2上的完成时间
	 	int sum2[]=new int [n+1];
	 	int bestTime=1000;  //假定最后的完成时间不超过1000
	 	for(i=1;i<=n;i++) //初始化调度方案
	 	{
	 		x[i]=-1;
	 		sum1[i]=0;
	 		sum2[i]=0;
	 	}
	 	//开始调度时使用
	 	sum1[0]=0;
	 	sum2[0]=0;
	 	k=1;  //调度第1个作业
	 	while(k>=1)
	 	{
	 		x[k]=x[k]+1;
	 		while(x[k]<n)
	 		{
	 			for(i=1;i<k;i++)
	 			{
	 				if(x[i]==x[k])//检测作业x[k]是否重复处理 
	 					break;
	 			}
	 			//判断前面是否处理过当前任务
	 			if(i==k)
	 			{
	 			/*1.判断加入当前任务后是否超过最短时间，若超过则考察下一个任务，否则可以
          2.判断前，首先要知道机器一加入当前任务后的完成时间与机器二完成上一个任务的时间谁先谁后
          3.选择较后的一个时间加上当前任务在机器二上完成的时间就等于当前任务的完成后的时间
        */
	 				sum1[k]=sum1[k-1]+a[x[k]]; //机器1当前的完成时间，a[x[k]]表示第k个作业在机器一上的处理时间
	 				if(sum1[k]>sum2[k-1])   //如果当前作业在机器1的完成时间大于上一个作业在机器二的完成时间
	 				{
	 					sum2[k]=sum1[k]+b[x[k]];
	 				}else
	 				{
	 					sum2[k]=sum2[k-1]+b[x[k]];
	 				}
	 				//判断加入当前任务时间与最短时间
	 				if(sum2[k]<=bestTime)
	 				{
	 					//小于，则继续
	 						break;
	 				}
	 				else  //已经超过目前最短时间，剪枝
	 				{
	 					x[k]=x[k]+1;
	 				}
	 			}
	 			else
	 			{
	 				x[k]=x[k]+1;  //作业x[k]已处理，尝试下一个作业
	 			}
	 		}
	 		//判断是否是最后一个，若不是，则进入下一个任务
	 		if(x[k]<n&&k<n)
	 		{
	 			k=k+1; //安排下一个作业
	 		}else
	 		{
	 			//判断是否是最后一个任务
	 			if(x[k]<n&&k==n)  
	 			{
	 				if(bestTime>=sum2[k])
	 				{
	 					bestTime=sum2[k];
	 					System.out.print("目前最短作业安排是：");
	 					for(int j=1;j<=n;j++)
	 					{
	 						System.out.print(x[j]+1+" "); //作业编号从1开始
	 					}
	 					System.out.println("最短时间是"+bestTime);
	 				}
	 				
	 			}
	 			//回溯(因为要找到最短时间，当前找到的只是当前最短时间)
	 			x[k]=-1;  //重置x[k],回溯
	 			k--;
	 		}
	 		
	 	}
	 	return bestTime;
	 } 

## [详细代码请点击此处](https://github.com/Azcy/Algorithm/blob/master/AlgorithmTypology/BacktrackingMethod/java/BatchJobProblem.java)

----------
4/5/2017 7:38:59 PM 